# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11dVnXM-t1qhEl9SIzuhQuMzHBBJuhwXF
"""

import streamlit as st
import pandas as pd
import numpy as np
import io
# Keep os if you still need OUTPUT_FILENAME definition, but file paths work differently in web apps
# import os

# --- Configuration ---
# Define the snap points (Keep as is)
SNAP_VALUES = [3, 6, 10, 12, 20, 24, 30, 40, 50, 60, 70, 80, 90, 100, 120, 150, 200, 250, 300, 500, 600, 1000]
OUTPUT_FILENAME = 'processed_pharmacy_orders.xlsx' # For the downloaded file name

# --- Helper Function for Snapping ---
# PASTE your snap_to_list function here (exactly as before)
def snap_to_list(value, snap_points):
    """
    Snaps a value to the closest point in a sorted list of snap points.
    ... (rest of the function code) ...
    """
    value = float(value) # Ensure value is float for comparisons
    if value <= 0:
        return 0
    if not snap_points:
        return int(round(value)) # Return rounded int if list is empty

    # Handle values below the first snap point (but > 0)
    if value < snap_points[0]:
        return snap_points[0]

    # Handle values above or equal to the last snap poin
    if value >= snap_points[-1]:
        return snap_points[-1]

    # Find the closest point for values within the range of snap_points
    closest_point = snap_points[0]
    min_diff = abs(value - closest_point)

    for point in snap_points[1:]:
        diff = abs(value - point)
        # If difference is smaller, this is the new closest
        if diff < min_diff:
            min_diff = diff
            closest_point = point
        # If difference is equal, prefer the higher snap point (rounds halves up)
        elif diff == min_diff and point > closest_point:
            closest_point = point

    return int(closest_point)


# --- Calculation Functions ---
# PASTE your calculate_actual_order function here (exactly as before)
def calculate_actual_order(row, snap_points_list):
    """
    Calculates the Actual_Order_QTY based on complex business rules
    ... (rest of the function code) ...
    """
    category = row['Item_Category']
    # Use the new AVG_30_Days_Cons for Repl_QTY calculation basis
    repl_qty = row['Repl_QTY']
    pharmacy_on_hand = row['Pharmacy_On_Hand']
    six_m_cons = row['6M_Cons']
    store_on_hand = row['Store_On_Hand']

    initial_actual_order = 0 # Start with 0

    # 1. Category-Specific Logic
    if category == 'Medicine':
        if pharmacy_on_hand == 0 and six_m_cons == 0 and store_on_hand >= 10:
             initial_actual_order = 3
        else:
            if repl_qty <= 50: initial_actual_order = repl_qty
            elif 50 < repl_qty <= 100: initial_actual_order = 70
            elif 100 < repl_qty <= 200: initial_actual_order = 100
            elif 200 < repl_qty <= 300: initial_actual_order = 200
            elif 300 < repl_qty <= 500: initial_actual_order = 300
            elif 500 < repl_qty <= 1000: initial_actual_order = 500
            elif 1000 < repl_qty <= 2000: initial_actual_order = 600
            elif repl_qty > 2000: initial_actual_order = repl_qty / 2
    elif category == 'Inpatient Medicine':
        if pharmacy_on_hand > 6000: initial_actual_order = 0
        elif six_m_cons == 0: initial_actual_order = 0
        else: initial_actual_order = repl_qty
    elif category == 'Diapers':
        if six_m_cons == 0: initial_actual_order = 0
        else: initial_actual_order = repl_qty / 2
    else: # Other categories
        initial_actual_order = repl_qty / 2

    # 2. General Low Store On Hand Rule
    if store_on_hand < 10:
        initial_actual_order = 0

    # 3. General Minimum Order Quantity Rule (Applied before snapping)
    # This ensures that if the logic results in e.g., 2, it becomes 3 before snapping.
    if 0 < initial_actual_order < 3:
        initial_actual_order = 3

    # 4. Final Snapping
    final_actual_order = snap_to_list(initial_actual_order, snap_points_list)

    return final_actual_order


# PASTE your process_pharmacy_orders function here
# SLIGHT MODIFICATION: Instead of printing errors/info, use st.error/st.warning/st.info
#                    Return None or an empty DataFrame on failure/no data.
def process_pharmacy_orders(df, selected_categories, snap_points_list):
    """
    Processes pharmacy order data from a DataFrame using Streamlit feedback.
    """
    try:
        # --- Data Validation ---
        required_columns = [
            'Item_Category', 'Item_Code', 'Item_Description',
            'Pharmacy_On_Hand', '1M_Cons', '3M_Cons', '6M_Cons',
            'Store_On_Hand'
        ]
        # Check specifically for 3M_Cons needed for the new average calculation
        if '3M_Cons' not in df.columns:
            st.error("ERROR: Required column '3M_Cons' is missing for average calculation.") # Use st.error
            return None
        missing_cols = [col for col in required_columns if col not in df.columns]
        if missing_cols:
            st.error(f"ERROR: Missing required columns in uploaded file: {', '.join(missing_cols)}") # Use st.error
            return None

        df_processed = df.copy()
        # Ensure numeric columns and fill NaNs
        numeric_cols = ['Pharmacy_On_Hand', '1M_Cons', '3M_Cons', '6M_Cons', 'Store_On_Hand']
        for col in numeric_cols:
            df_processed[col] = pd.to_numeric(df_processed[col], errors='coerce')
        df_processed[numeric_cols] = df_processed[numeric_cols].fillna(0)
        # Ensure Item_Category is string
        if 'Item_Category' in df_processed.columns:
             df_processed['Item_Category'] = df_processed['Item_Category'].astype(str)


        # --- Filtering ---
        if not selected_categories:
            st.warning("No categories were selected for processing.") # Use st.warning
            return pd.DataFrame() # Return empty DataFrame is better than None here

        df_filtered = df_processed[df_processed['Item_Category'].isin(selected_categories)].copy()

        if df_filtered.empty:
            st.info("No items found matching the selected category criteria.") # Use st.info
            # Define columns for empty DataFrame to avoid errors later
            output_columns = required_columns + ['AVG_30_Days_Cons', 'Repl_QTY', 'Actual_Order_QTY']
            return pd.DataFrame(columns=output_columns) # Return empty DataFrame with expected columns

        # --- Calculation: AVG_30_Days_Cons (NEW) ---
        df_filtered['AVG_30_Days_Cons'] = (df_filtered['3M_Cons'] / 3).round(2)

        # --- Calculation: Repl_QTY (Using NEW Average) ---
        df_filtered['Repl_QTY'] = df_filtered['AVG_30_Days_Cons'] - df_filtered['Pharmacy_On_Hand']
        df_filtered['Repl_QTY'] = df_filtered['Repl_QTY'].clip(lower=0).round(2)

        # --- Calculation: Actual_Order_QTY (with Snapping) ---
        df_filtered['Actual_Order_QTY'] = df_filtered.apply(
            calculate_actual_order,
            axis=1,
            snap_points_list=snap_points_list
        )

        # --- Final Output Preparation ---
        output_columns = [
            'Item_Category', 'Item_Code', 'Item_Description',
            'Pharmacy_On_Hand', '1M_Cons', '3M_Cons', '6M_Cons',
            'Store_On_Hand', 'AVG_30_Days_Cons', 'Repl_QTY', 'Actual_Order_QTY'
        ]
        # Ensure all expected columns exist, add missing ones with default value if necessary
        for col in output_columns:
            if col not in df_filtered.columns:
                df_filtered[col] = 0 # Or np.nan, depending on desired output for missing calculated columns

        df_final = df_filtered[output_columns]
        return df_final

    except Exception as e:
        st.error(f"An unexpected error occurred during processing: {e}") # Use st.error
        # raise e # Keep commented out for production app
        return None

# --- Streamlit App UI ---

st.set_page_config(layout="wide") # Use wider layout
st.title("Pharmacy Order Preparation Tool")
st.write("Upload your Excel file, select categories, and process the orders.")

# 1. File Upload
uploaded_file = st.file_uploader("Choose an Excel file (.xlsx, .xls)", type=['xlsx', 'xls'])

if uploaded_file is not None:
    st.info(f"File '{uploaded_file.name}' uploaded successfully.")
    try:
        # Read the uploaded file into a pandas DataFrame
        # Use BytesIO as read_excel expects a file path or buffer
        df_input = pd.read_excel(uploaded_file) # Streamlit handles the file object correctly

        # Basic validation - check essential columns before proceeding
        if 'Item_Category' not in df_input.columns:
             st.error("Error: The uploaded file must contain an 'Item_Category' column.")
        elif '3M_Cons' not in df_input.columns:
             st.error("Error: The uploaded file must contain a '3M_Cons' column.")
        else:
            st.success("File read and basic columns validated.")

            # 2. Category Selection
            try:
                # Ensure category column is string type and handle potential NaN/None
                df_input['Item_Category'] = df_input['Item_Category'].astype(str).fillna('Unknown')
                available_categories = sorted(df_input['Item_Category'].unique().tolist())

                if not available_categories or (len(available_categories) == 1 and available_categories[0] == 'Unknown'):
                     st.warning("No valid categories found in the 'Item_Category' column.")
                else:
                    st.subheader("Select Categories to Process")
                    # Option to process all or select specific categories
                    process_option = st.radio("Choose processing mode:", ('Process ALL available categories', 'SELECT specific categories'))

                    categories_to_process = []
                    if process_option == 'Process ALL available categories':
                        categories_to_process = available_categories
                        st.write(f"**Selected:** Processing all {len(categories_to_process)} categories.")
                    else:
                        # Provide a multi-select dropdown
                        categories_to_process = st.multiselect(
                            "Select categories:",
                            options=available_categories,
                            default=[] # No default selection
                        )
                        if categories_to_process:
                           st.write(f"**Selected:** {', '.join(categories_to_process)}")
                        else:
                           st.warning("Please select at least one category.")

                    # 3. Process Button
                    if st.button("Process Orders", disabled=(not categories_to_process)): # Disable button if no categories selected
                        if categories_to_process:
                            with st.spinner("Processing orders... Please wait."): # Show spinner during processing
                                processed_df = process_pharmacy_orders(df_input, categories_to_process, SNAP_VALUES)

                            if processed_df is not None:
                                if not processed_df.empty:
                                    st.success("Processing Complete!")
                                    st.subheader("Processed Order Data Preview")
                                    st.dataframe(processed_df.head(20)) # Show top 20 rows

                                    # 4. Download Button - Convert DataFrame to Excel in memory
                                    output = io.BytesIO()
                                    with pd.ExcelWriter(output, engine='openpyxl') as writer:
                                        processed_df.to_excel(writer, index=False, sheet_name='ProcessedOrders')
                                    excel_data = output.getvalue()

                                    st.download_button(
                                        label="ðŸ“¥ Download Processed Excel File",
                                        data=excel_data,
                                        file_name=OUTPUT_FILENAME,
                                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                                    )
                                else:
                                    # process_pharmacy_orders function already shows info message
                                    st.info("Processing finished, but no data resulted (check selections and file).")
                            else:
                                # process_pharmacy_orders function already shows error message
                                st.error("Processing failed. Check error messages above.")
                        else:
                            st.warning("Cannot process without selecting categories.") # Should not happen if button is disabled correctly

            except Exception as e:
                 st.error(f"An error occurred during category selection or processing setup: {e}")

    except Exception as e:
        st.error(f"Error reading or parsing the Excel file: {e}")
        st.warning("Please ensure the file is a valid Excel (.xlsx or .xls) file and not corrupted.")

else:
    st.info("Upload an Excel file to begin.")

st.markdown("---")
st.caption("Pharmacy Order Preparation App")